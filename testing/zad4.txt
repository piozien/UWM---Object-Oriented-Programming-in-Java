Stwórz w klasie tylko jeden prywatny konstruktor z jednym argumentem. Z argumentu ustaw
wartość pola price. Zabronione jest tworzenie innych konstruktorów.
class Table {
    private double price;

    private Table(double price) {
        this.price = price;
    }

    public static Table create(double price) {
      return new Table(price);
    }
}
public class TestTable {
    public static void main(String[] args) {
        Table t1 = Table.create(123.45);
        System.out.println(t1);

    }
}
-------------------------------------------
W klasie Vehicle, zaimplementuj statyczną metodę createCar(String brand, String
model, int year). Metoda ma zwrócić nowy obiekt typu Vehicle, którego pola ustawione są z
argumentów metody.
W klasie Vehicle, zaimplementuj nie-statyczną metodę createVehicle(String brand,
String model, int year). Metoda ma zwrócić nowy obiekt typu Vehicle, którego pola ustawione są z
argumentów metody.

public class Vehicle {
    private String brand;
    private String model;
    private int year;

    private Vehicle(String brand, String model, int year) {
        this.brand = brand;
        this.model = model;
        this.year = year;
    }
    public Vehicle(){
    }
    public static Vehicle createCar(String brand, String model, int year) {
        return new Vehicle(brand, model, year);
    }
    public Vehicle createVehicle(String brand, String model, int year) {
        return new Vehicle(brand, model, year);
    }
}

package moto;

public class TestVehicle {
    public static void main(String[] args) {
        Vehicle car = Vehicle.createCar("Mercedes","C", 2020 );
        Vehicle moto = new Vehicle();
        moto =  moto.createVehicle("Honda", "CBR", 2019);
    }
}
-------------------------------------
W klasie Appliance, zaimplementuj statyczną metodę createFridge(String brand, String
model, double powerUsage). Metoda ma zwrócić nowy obiekt typu Appliance, którego pola ustawione
są z argumentów metody.
W klasie Appliance, zaimplementuj nie-statyczną metodę createAppliance(String brand,
String model, double powerUsage). Metoda ma zwrócić nowy obiekt typu Appliance, którego pola
ustawione są z argumentów metody.

private Appliance(String brand, String model, double powerUsage) {
        this.brand = brand;
        this.model = model;
        this.powerUsage = powerUsage;
    }

    public Appliance() {
    }
    public static Appliance createFridge(String brand, String model, double powerUsage){
     return new Appliance(brand, model, powerUsage);
    }
    public Appliance createAppliance(String brand, String model, double powerUsage){
        return new Appliance(brand, model, powerUsage);
    }
}
public class TestAppliance {
    public static void main(String[] args) {
        Appliance fridge = Appliance.createFridge("test","test_model", 2.5 );
        Appliance app = new Appliance();
        app =  app.createAppliance("test1", "test_model2", 2.65);
    }
}
------------------------------
Stwórz abstrakcyjną klasę Animal zawierającą publiczną abstrakcyjną metodę makeSound(),
która nie przyjmuje argumentów i zwraca String. Klasę umieść w pakiecie zoo.
    Utwórz dwie klasy pochodne od Animal: Dog i Cat. W obu klasach nadpisz metodę makeSound().
Dla Dog niech zwraca "Bark", a dla Cat "Meow".
    W klasie TestAnimal w pakiecie zoo utwórz tablicę typu Animal i zainicjalizuj ją 5 instancjami
Dog i Cat. Iteruj po tablicy wywołując metodę makeSound() dla każdego zwierzęcia.

public abstract class Animal {
    public abstract String makeSound();
}
class Cat extends Animal {
    @Override
    public String makeSound() {
        return("Meow");
    }
}
class Dog extends Animal {
    @Override
    public String makeSound() {
        return("Bark");
    }
}
public class TestAnimal {
    public static void main(String[] args) {
        Animal[] animals = new Animal[5];
        animals[0] = new Dog();
        animals[1] = new Cat();
        animals[2] = new Dog();
        animals[3] = new Cat();
        animals[4] = new Dog();
        for (Animal animal : animals) {
            System.out.println(animal.makeSound());
        }
    }
}
--------------------------
Stwórz klasę Employee reprezentującą pracownika. Klasę umieść w pakiecie pl.com.corporation.
Klasa powinna zawierać:
• Prywatne pola: name (typu String), salary (typu double).
• Publiczny konstruktor przyjmujący name i salary jako argumenty i ustawiający te pola.
• Metody getter dla obu pól.
    Dodaj statyczne prywatne pole totalEmployeeCount typu int w klasie Employee, które będzie
śledzić łączną liczbę utworzonych pracowników. Zmodyfikuj konstruktor klasy Employee, aby każde
utworzenie nowego obiektu Employee inkrementowało totalEmployeeCount.
    Dodaj publiczną statyczną metodę getTotalEmployeeCount, która zwraca wartość pola
totalEmployeeCount.
    W klasie TestEmployee (inny plik w tym samym pakiecie) w metodzie main utwórz 5 obiektów
Employee Wyświetl łączną liczbę stworzonych pracowników.

class Employee {
    private String name;
    private double salary;
    private static int totalEmployeeCount;

    public Employee(String name, double salary) {
        this.name = name;
        this.salary = salary;
        totalEmployeeCount++;
    }

    

    public static int getTotalEmployeeCount() {
        return totalEmployeeCount;
    }
}
public class TestEmployee {
    public static void main(String[] args) {
        Employee[] em = new Employee[5];
        em[0] = new Employee("0", 0.0);
        em[1] = new Employee("1", 1.0);
        em[2] = new Employee("2", 2.0);
        em[3] = new Employee("3", 3.0);
        em[4] = new Employee("4", 4.0);
        System.out.println(Employee.getTotalEmployeeCount());
    }

}



